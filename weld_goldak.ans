
/solu
film_coeff = 30				! convection coefficient
amb_temp = 20				! ambient temperature				

!  solver settings, if PCG doesn't work use SRAPSE	
EQSLV,PCG
TRNOPT,full
NEQIT,60
thopt,full
!------------Parameters (assumed unit system: MKS)---------------
!------------Laser direction (local coord system): Z-------------
a = 0.0012						! x radius in local 
b = 0.0010						! y radius in local 
c1 = 0.002						! z front radius in local 
c2 = 0.004						! z rear radius in local 

ff = 1.33						! front factor
fr = 2-ff						! rear factor (preset, don't change)

q = 884/.8						! W, energy
vel = 780/1000/60				! velocity
	

time_cool = 400					! cooling time after welding was finished
heat_tolerance = 0.001			! if resulting heat is less it is set to 0

c1_live_ratio = 1.5				! multiplier for activating dead elements

!--------------Paths---------------
!#
path_num = 1				!number of paths
*dim,x_start,,path_num
*dim,y_start,,path_num
*dim,z_start,,path_num
*dim,x_finish,,path_num
*dim,y_finish,,path_num
*dim,z_finish,,path_num
*dim,steps,,path_num

steps(1) = 120		!steps each path is divided in
!starting coordinates
x_start(1) = 0.0					
y_start(1) = 0.001					
z_start(1) = 0.02		
!finish coordinates			
x_finish(1) = 0.0				
y_finish(1) = 0.001						
z_finish(1) = 0.08	
	
		
!------------Processing-------------
cmsel,s,killed_elems		! kill elements in "killed_elems" selection
ekill,all


time_weld_overall = 0			! overall process time
csys,0				!set active CS to 0 (global cartesian)
c_num = 120			!local csys number (unimportant)
! loop over each path
*do,kk,1,path_num
	! path length
	direct_len = ((x_start(kk)-x_finish(kk))**2+(y_start(kk)-y_finish(kk))**2+(z_start(kk)-z_finish(kk))**2)**0.5
	! guide angles
	cos_x = (x_finish(kk)-x_start(kk))/direct_len
	cos_y = (y_finish(kk)-y_start(kk))/direct_len
	cos_z = (z_finish(kk)-z_start(kk))/direct_len

	! starting positions for each component
	x_s_active = x_start(kk)
	y_s_active = y_start(kk)
	z_s_active = z_start(kk)
	
	time_weld = direct_len/vel					! welding time for path
	time_step_weld = time_weld/steps(kk)		! timestep for each new heat source position

	! loop over each step in a path
	*do,ii,1,steps(kk)+1
		!deleting all heat generation from previous step		
		esel,all
		bfedele,all,HGEN		
		
		time_stepped = ii*time_step_weld	! time of the welding process for a path
		time_sol = (ii-1)*time_step_weld	! time for calculating current position of the heat source

		! set solution time to the time of the current step + time accumulated from previous steps
		wtime = time_weld_overall+time_stepped
		time,wtime

		! current heat source position
		x_weld = x_s_active+vel*time_sol*cos_x
		y_weld = y_s_active+vel*time_sol*cos_y
		z_weld = z_s_active+vel*time_sol*cos_z

		! aline local csys z axis with directional vector
		! NOTE: there might be some edge cases this will work incorrectly in so be cautious
		! 		i can't be bothered to test this thoroughly, this is a super-old script after all

		*afun,deg	! set to degrees
		! "clocal" creates CS based on the current active CS
		clocal,c_num-1,0,x_weld,y_weld,z_weld,0,0,acos(cos_z)*SIGN(1,cos_x)
		clocal,c_num,0,0,0,0,0,(90-acos(cos_y)),0
		*afun,rad	! set to radians
		
		csys,c_num				! activate local csys
		
		! select dead elements in a an interval between -c2..c1*c1_live_ratio and make them alive
		! NOTE: this is a sub-optimal solution, a better way would be to select in a sphere or a cylinder 
		!		one just needs to create additional local CS in the same position as c_num, but yet again
		! 		i can't be bothered to fix this
		cmsel,s,killed_elems
		esel,u,live
		esel,r,cent,z,-c2,c1*c1_live_ratio
		ealive,all
		
		! select all viable elements to apply heat to
		csys,0
		cmsel,s,weld_layer			! "weld_layer" is a selection of elements that can receive heat 
		csys,c_num
		esel,r,live
		cm,selected_elements,elem

		! loop over all selected elements
		cmsel,s,selected_elements
		curr_el = 0
		curr_el = elnext(curr_el)	! get number of the next element in the selection
		*dowhile,curr_el
			! if "curr_el" equal to the highest element number in the 
			! selection it will return 0 thus we ensure we looped over selection completely

			! get current element position in local CS
			*get,x1,elem,curr_el,cent,x
			*get,y1,elem,curr_el,cent,y
			*get,z1,elem,curr_el,cent,z
			
			! selecting if front or rear
			*if,z1,gt,0,then 
				c = c1
				f1 = ff
			*else
				c = c2
				f1 = fr
			*endif

			! applying heat generation on elements
			! NOTE: this is a sub-optimal solution, it is neccessary to avoid repeated calculations
			! 		as much as possible for speed (even tho it might seem insignificant it all adds up in big simulations)
			! 		so you should divide this formulas into parts that can be calculated outside the loop for reuse and parts
			! 		which you need to recalculate for every element
			part1 = (6*(3**0.5)*f1*q)/(a*b*c*3.14*(3.14**0.5))
			part2 = (exp(-3*(x1/a)**2))*(exp(-3*(y1/b)**2))*(exp(-3*((z1/c)**2)))
			qf = part1*part2 
			
			! not bothering to apply heat if it's too low
			! dunno how it affects performance, i don't remember it making a difference
			*if,qf,gt,heat_tolerance,then
				bfe,curr_el,HGEN,,qf	
			*endif			
		*enddo

		allsel					! always "allsel" before solve
		solve

		csdele,c_num			! deleting local csys, this is unneccessary
		csdele,c_num-1

		csys,0					! returning to global csys

		! get next element number
		cmsel,s,selected_elements
		curr_el = elnext(curr_el)
	*enddo
	
	! add time for current path to overall time
	time_weld_overall = time_weld_overall+time_weld
	esel,all
	bfedele,all,HGEN		! deleting all heat generation
*enddo

! cooling step
allsel
TIME,time_weld_overall
autots,on    						! use automatic time-stepping
deltim, 10, 5, 40, on
TIME,time_weld_overall+time_cool	! cooling time